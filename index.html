<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Pokedle (Gen 1 z pliku JSON)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px auto;
      max-width: 1000px;
      text-align: center;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .section {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .hidden {
      display: none;
    }
    .input-field {
      margin: 10px 0;
    }
    .feedback {
      margin-top: 20px;
      font-weight: bold;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      padding: 8px;
      border: 1px solid #ccc;
      vertical-align: middle;
      text-align: center;
    }
    th {
      background-color: #f9f9f9;
    }
    /* Kolory w zależności od trafienia */
    .correct {
      background-color: #c4f3c4; /* zielonkawe */
    }
    .wrong {
      background-color: #f6c6c6; /* czerwonawe */
    }
    .close {
      background-color: #f9f5c4; /* żółtawe */
    }
    .sprite {
      width: 56px;
      height: 56px;
      image-rendering: pixelated; /* pikselowy styl spritów */
    }
  </style>
</head>
<body>

  <h1>Pokedle (Gen 1) – oparte na pliku JSON</h1>

  <!-- Sekcja ustawienia docelowego Pokémona -->
  <div class="section" id="setup-section">
    <h2>Wybierz lub wylosuj Pokémona do odgadnięcia</h2>
    
    <div class="input-field">
      <label for="secretPokemon">Nazwa (angielska) lub numer (1–151):</label><br>
      <input type="text" id="secretPokemon" placeholder="np. Bulbasaur lub 1">
      <button id="setSecretBtn">Ustaw</button>
      <button id="randomSecretBtn">Wylosuj</button>
    </div>
    <p>Po ustawieniu/wylosowaniu docelowego Pokémona, sekcja się ukryje, a Ty przejdziesz do zgadywania.</p>
  </div>

  <!-- Sekcja zgadywania -->
  <div class="section hidden" id="guess-section">
    <h2>Zgaduj!</h2>
    <div class="input-field">
      <label for="guessInput">Twoja propozycja (nazwa lub numer):</label><br>
      <input type="text" id="guessInput" placeholder="np. Pikachu lub 25">
      <button id="guessBtn">Zgaduj</button>
    </div>
    <p>Wpisz nazwę (angielską) lub ID Pokémona z 1. generacji.</p>
    <div id="feedback" class="feedback"></div>

    <!-- Tabela prób zgadywania -->
    <table id="guessesTable">
      <thead>
        <tr>
          <th>Próba</th>
          <th>Obrazek (zgadywany)</th>
          <th>Typ 1</th>
          <th>Typ 2</th>
          <th>Wzrost (m)</th>
          <th>Waga (kg)</th>
        </tr>
      </thead>
      <tbody>
        <!-- Wypełniane dynamicznie przez JS -->
      </tbody>
    </table>
  </div>

  <script>
    // Tablica z danymi z pliku JSON (po filtracji do Gen 1)
    let pokemonList = [];
    let secretPokemon = null; // wylosowany/ustawiony Pokémon
    let guessCount = 0;

    // Referencje do elementów
    const setupSection       = document.getElementById('setup-section');
    const guessSection       = document.getElementById('guess-section');
    const secretPokemonInput = document.getElementById('secretPokemon');
    const setSecretBtn       = document.getElementById('setSecretBtn');
    const randomSecretBtn    = document.getElementById('randomSecretBtn');
    const guessInput         = document.getElementById('guessInput');
    const guessBtn           = document.getElementById('guessBtn');
    const feedbackEl         = document.getElementById('feedback');
    const guessesTableBody   = document.getElementById('guessesTable').querySelector('tbody');

    // Po załadowaniu DOM ładujemy plik JSON
    window.addEventListener('DOMContentLoaded', () => {
      fetch('pokedex.json')
        .then(res => res.json())
        .then(data => {
          // Filtrujemy do 1. generacji, czyli ID <= 151
          pokemonList = data.filter(p => p.id && p.id <= 151);
          console.log('Wczytano Gen 1 Pokémonów:', pokemonList.length);
        })
        .catch(err => {
          console.error('Błąd przy wczytywaniu JSON:', err);
        });
    });

    // Ustawianie Pokémona (ręcznie)
    setSecretBtn.addEventListener('click', () => {
      const input = secretPokemonInput.value.trim();
      if (!input) {
        alert('Podaj nazwę/ID Pokémona lub wylosuj!');
        return;
      }
      setSecret(input);
    });

    // Losowanie Pokémona
    randomSecretBtn.addEventListener('click', () => {
      setSecret(null);
    });

    // Zgadywanie
    guessBtn.addEventListener('click', handleGuess);
    guessInput.addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        handleGuess();
      }
    });

    /**
     * Funkcja znajdująca Pokémona po ID (1..151) lub nazwie angielskiej
     * (bez względu na wielkość liter).
     */
    function findPokemon(input) {
      const lower = input.toString().trim().toLowerCase();
      const asNumber = Number(lower);

      // 1) Spróbuj jako numer
      if (!isNaN(asNumber) && asNumber > 0) {
        return pokemonList.find(p => p.id === asNumber);
      }
      // 2) W innym wypadku szukaj po name.english
      return pokemonList.find(p => p.name && p.name.english.toLowerCase() === lower);
    }

    /**
     * Ustawia (lub losuje) sekretnego Pokémona.
     */
    function setSecret(inputNameOrId) {
      if (!pokemonList || pokemonList.length === 0) {
        alert('Lista Pokémonów (Gen 1) nie została wczytana.');
        return;
      }

      let chosenPokemon = null;

      if (inputNameOrId) {
        chosenPokemon = findPokemon(inputNameOrId);
        if (!chosenPokemon) {
          alert('Nie znaleziono takiego Pokémona o ID ≤ 151.');
          return;
        }
      } else {
        // Wylosuj
        const randIndex = Math.floor(Math.random() * pokemonList.length);
        chosenPokemon = pokemonList[randIndex];
      }

      secretPokemon = chosenPokemon;
      guessCount = 0;
      guessesTableBody.innerHTML = ''; // wyczyszczenie tabeli

      // Przechodzimy do sekcji zgadywania
      setupSection.classList.add('hidden');
      guessSection.classList.remove('hidden');
      feedbackEl.textContent = 'Sekretny Pokémon został ustawiony. Czas zgadywać!';
    }

    /**
     * Obsługa przycisku "Zgaduj"
     * - Szuka Pokémona w liście
     * - Porównuje parametry (typ, wzrost, waga)
     */
    function handleGuess() {
      if (!secretPokemon) {
        alert('Najpierw ustaw lub wylosuj sekretnego Pokémona!');
        return;
      }
      const input = guessInput.value.trim();
      if (!input) {
        alert('Wpisz nazwę lub numer Pokémona!');
        return;
      }

      const guessed = findPokemon(input);
      if (!guessed) {
        alert('Nie znaleziono takiego Pokémona o ID ≤ 151.');
        return;
      }

      // Porównujemy
      const comparison = comparePokemons(guessed, secretPokemon);

      // Dodajemy wiersz w tabeli z wynikiem
      addGuessRow(guessed, comparison);

      // Sprawdzamy, czy trafiony
      if (comparison.nameCorrect) {
        feedbackEl.textContent = 'BRAWO! To właściwy Pokémon!';
      } else {
        feedbackEl.textContent = 'To jeszcze nie to. Spróbuj ponownie!';
      }

      guessInput.value = '';
      guessInput.focus();
    }

    /**
     * Porównanie parametrów:
     * - nameCorrect: czy id i/lub nazwa angielska pokrywają się
     * - typeMatch: czy typy są takie same, częściowo się pokrywają itp.
     * - height/weight: czy jest taki sam, za niski, za wysoki?
     *
     * Uwaga: w JSON są wysokości np. "0.7 m", "6.9 kg" (czasem)
     *        Trzeba wyciągnąć liczbę z "profile.height"/"profile.weight".
     */
    function comparePokemons(guessed, secret) {
      const result = {
        nameCorrect: false,
        typeMatch: 'none',
        heightInfo: '',
        weightInfo: ''
      };

      // 1) Nazwa (ID) – jeśli to ten sam Pokémon
      if (guessed.id === secret.id) {
        result.nameCorrect = true;
      }

      // 2) Typ
      const guessedTypes = guessed.type.map(t => t.toLowerCase());
      const secretTypes  = secret.type.map(t => t.toLowerCase());
      const intersection = guessedTypes.filter(t => secretTypes.includes(t));

      if (intersection.length === secretTypes.length && guessedTypes.length === secretTypes.length) {
        result.typeMatch = 'perfect';
      } else if (intersection.length > 0) {
        result.typeMatch = 'partial';
      } else {
        result.typeMatch = 'none';
      }

      // 3) Wzrost
      const guessedH = parseFloat((guessed.profile.height || '0').replace(' m','').replace(',','.'));
      const secretH  = parseFloat((secret.profile.height  || '0').replace(' m','').replace(',','.'));
      if (!isNaN(guessedH) && !isNaN(secretH)) {
        if (guessedH === secretH) {
          result.heightInfo = 'poprawny';
        } else if (guessedH < secretH) {
          result.heightInfo = 'za niski';
        } else {
          result.heightInfo = 'za wysoki';
        }
      }

      // 4) Waga
      const guessedW = parseFloat((guessed.profile.weight || '0').replace(' kg','').replace(',','.'));
      const secretW  = parseFloat((secret.profile.weight  || '0').replace(' kg','').replace(',','.'));
      if (!isNaN(guessedW) && !isNaN(secretW)) {
        if (guessedW === secretW) {
          result.weightInfo = 'poprawna';
        } else if (guessedW < secretW) {
          result.weightInfo = 'za niska';
        } else {
          result.weightInfo = 'za wysoka';
        }
      }

      return result;
    }

    /**
     * Dodaje wiersz w tabeli (nr próby, sprite, typ1, typ2, height, weight)
     * Koloryzujemy komórki na podstawie "comparison".
     */
    function addGuessRow(guessed, comparison) {
      guessCount++;
      const row = document.createElement('tr');

      // 1) Numer próby
      const attemptCell = document.createElement('td');
      attemptCell.textContent = guessCount;
      row.appendChild(attemptCell);

      // 2) Obrazek (sprite)
      const imgCell = document.createElement('td');
      const img = document.createElement('img');
      img.src = guessed.image?.sprite || '';
      img.alt = '???'; // celowo nie pokazujemy nazwy
      img.className = 'sprite';
      imgCell.appendChild(img);
      row.appendChild(imgCell);

      // 3) Typ 1
      const type1Cell = document.createElement('td');
      const t1 = guessed.type[0] || '';
      type1Cell.textContent = t1;
      colorTypeCell(type1Cell, comparison.typeMatch, t1);
      row.appendChild(type1Cell);

      // 4) Typ 2
      const type2Cell = document.createElement('td');
      const t2 = guessed.type[1] || '';
      type2Cell.textContent = t2;
      // Tylko koloryzujemy, jeśli jest 2. typ
      colorTypeCell(type2Cell, comparison.typeMatch, t2);
      row.appendChild(type2Cell);

      // 5) Wzrost
      const heightCell = document.createElement('td');
      const guessedH = guessed.profile.height || '';
      heightCell.textContent = guessedH + ' (' + comparison.heightInfo + ')';
      if (comparison.heightInfo === 'poprawny') {
        heightCell.className = 'correct';
      } else if (comparison.heightInfo.startsWith('za ')) {
        heightCell.className = 'wrong';
      }
      row.appendChild(heightCell);

      // 6) Waga
      const weightCell = document.createElement('td');
      const guessedW = guessed.profile.weight || '';
      weightCell.textContent = guessedW + ' (' + comparison.weightInfo + ')';
      if (comparison.weightInfo === 'poprawna') {
        weightCell.className = 'correct';
      } else if (comparison.weightInfo.startsWith('za ')) {
        weightCell.className = 'wrong';
      }
      row.appendChild(weightCell);

      guessesTableBody.appendChild(row);
    }

    /**
     * Funkcja pomocnicza do koloryzowania komórki typu.
     * - 'perfect' => zielono (correct)
     * - 'partial' => żółto (close)
     * - 'none'    => czerwo (wrong)
     * UWAGA: Nie malujemy na żółto, jeśli dany Pokémon wcale nie ma drugiego typu
     *        albo jeśli guessed Pokémon ma typ, którego secret nie ma (type2 = '' i partial=1).
     */
    function colorTypeCell(cell, matchResult, typeValue) {
      if (!typeValue) {
        return; // puste - brak 2. typu
      }
      switch (matchResult) {
        case 'perfect':
          cell.className = 'correct';
          break;
        case 'partial':
          cell.className = 'close';
          break;
        default:
          cell.className = 'wrong';
          break;
      }
    }
  </script>
</body>
</html>
